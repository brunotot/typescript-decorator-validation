type _Exclude<TParent, TExclude> = Pick<TParent, $.Values<{
    [Prop in $.Keys<TParent>]: [TParent[Prop]] extends [TExclude] ? never : Prop;
}>>;
type _ParamsFactory<T extends any[]> = T extends [] ? [] : T extends [infer P] ? [P] : T extends [infer P, ...infer Rest] ? [P, ..._ParamsFactory<Rest>] : T extends [...infer Rest, infer P] ? [..._ParamsFactory<Rest>, P] : never;
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? A : B;
type _WritableKeys<T> = {
    [P in keyof T]-?: IfEquals<{
        [Q in P]: T[P];
    }, {
        -readonly [Q in P]: T[P];
    }, P>;
}[keyof T];
type _Nullable<GUARD = undefined> = GUARD extends undefined ? any : GUARD | undefined | null;
export declare namespace $ {
    type Nullable<TGuard = undefined> = _Nullable<TGuard>;
    type Optional<T extends object> = {
        [K in keyof T]?: NonNullable<T[K]>;
    };
    type Equals<T> = (a: T, b: T) => boolean;
    type Exclude<TFrom, TRemove> = _Exclude<TFrom, TRemove>;
    type ExcludeNever<TActual> = Exclude<TActual, never>;
    type FuncFactory<T extends any[], R> = (...args: ParamsFactory<T>) => R;
    type HashGenerator<T> = (value: T) => number;
    type Keys<T> = keyof T;
    type Object<V> = Record<string, V>;
    type ParamsFactory<T extends any[]> = _ParamsFactory<T>;
    type Predicate<T> = (value: T, index: number, array: T[]) => boolean;
    type Values<T> = T[$.Keys<T>];
    type WritableKeys<T> = _WritableKeys<T>;
    type _ = undefined;
}
export {};
